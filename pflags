#!/usr/bin/env python3

import argparse
import ast
import re
import sys

class ERROR_CODE:
  SUCCESS = 0
  ERROR = 1
  USAGE = 2
  NOT_FOUND = 3

PROG = None

PARSED_ARGS = None

PARSE_COMMAND_USAGE_SUFFIX = '''\
---- <Defind flags options> -- <Defind flags options> -- ... ---- <To be parsed args>'''

PARSE_COMMAND_DESC = '''\
Parses and validates the args based on the defined flag options

Note: <Defind flags options> are separated by hypen(--)'''

def add_parse_subparser(sub_parsers: argparse._SubParsersAction):
  flags_def_parser = argparse.ArgumentParser(usage='', description='', add_help=False, formatter_class=argparse.RawTextHelpFormatter)
  flags_def_parser.add_argument('-s', '--short', metavar='', help='Short name for flag')
  flags_def_parser.add_argument('-l', '--long', metavar='', help='Long name for flag')
  allowed_values = ['string', 'number', 'bool']
  flags_def_parser.add_argument('-t', '--type', metavar='', required=True, help='Type of flag. (required)\n  Allowed values: {}'.format(', '.join(allowed_values)), choices=allowed_values)
  flags_def_parser.add_argument('-h', '--help', metavar='', help='Help of the flag')
  flags_def_parser.add_argument('-r', '--required', action='store_true', help='If a flag is required')
  flags_def_parser.add_argument('--default', metavar='', type=str, action='append', help='Default values\n  (Can be specified multiple times)')
  flags_def_parser.add_argument('-a', '--allowed', metavar='', type=str, action='append', help='Allowed Values\n  (Can be specified multiple times)')
  flags_def_parser.add_argument('--regex', metavar='', help='Regex for string validatin\n  (Only applicable to --type=string)')
  parser: argparse.ArgumentParser = sub_parsers.add_parser(name='parse', description=PARSE_COMMAND_DESC, add_help=True, formatter_class=get_parse_cmd_help_formatter(flags_def_parser))
  parser.add_argument('--name', dest='__cmd_name__', metavar='', required=True, type=str, help='Name of parent command, it will be referenced in errors')
  parser.add_argument('--usage', metavar='', type=str, help='Provide custom usage for command', default=None)
  parser.add_argument('--description', metavar='', type=str, default=None, help='Desciption of command')
  return parser, flags_def_parser

def split_list_by_first_occurrence(args: list, delimiter: str, n:int = None) -> list[list]:
  if n is not None and n < 1:
    raise ValueError('Invalid n, it should be greater than 0')
  res = []
  buf = []
  for arg in args:
    if (n is None or len(res) < n) and arg == delimiter:
      res.append(buf)
      buf = []
      continue
    buf.append(arg)
  res.append(buf)
  if n is None or len(res) == n + 1:
    return res
  return res + [[]] * (n + 1 - len(res))

def get_parse_cmd_help_formatter(flags_def_parser: argparse.ArgumentParser):
  class ParseCmdHelpFormatter(argparse.RawTextHelpFormatter):
    def _format_usage(self, usage, actions, groups, prefix):
      return super()._format_usage(usage, actions, groups, prefix).rstrip('\n') + f' {PARSE_COMMAND_USAGE_SUFFIX}\n\n'

    def format_help(self):
      help = super().format_help()
      if len(help.splitlines()) == 1:
        return help
      flags_def_help = 'Flags defining options:' + flags_def_parser.format_help().lstrip('usage:').strip(' ').strip('\n').strip('options:')
      return '{}\n{}\n'.format(help, flags_def_help)
  return ParseCmdHelpFormatter

def validate_flag_values(FLAGS_DEF):
  def string_type(val):
    if FLAGS_DEF.allowed and val not in FLAGS_DEF.allowed:
      raise argparse.ArgumentTypeError(f'{val} is not in allowed values: {FLAGS_DEF.allowed}')
    if FLAGS_DEF.regex:
      regx = re.compile(FLAGS_DEF.regex)
      if not regx.match(val):
        raise argparse.ArgumentTypeError(f'{val} is not matching regex: {FLAGS_DEF.regex}')
    return val

  def number_type(val):
    try:
      return int(val)
    except ValueError:
      try:
        return float(val)
      except ValueError:
        raise argparse.ArgumentTypeError("Expecting number")

  def bool_type(val):
    if val not in ['true', 'false']:
      raise argparse.ArgumentTypeError("Expecting true or false")
    return bool(val)

  if FLAGS_DEF.type == 'string':
    return string_type
  if FLAGS_DEF.type == 'number':
    return number_type
  if FLAGS_DEF.type == 'bool':
    return bool_type

def stringify_flag_value(val: any):
  if isinstance(val, bool):
    return 'true' if val else 'false'
  if isinstance(val, str):
    val = val.replace("'", "'\\''")
    return f"'{val}'"
  return str(val)

def parse_cmd(external_args: list[str], flags_def_parser: argparse.ArgumentParser):
  external_cmd_name = PARSED_ARGS.__cmd_name__
  flags_def_args_raw, to_be_parsed = split_list_by_first_occurrence(external_args, '----', n=1)
  flags_def_args = split_list_by_first_occurrence(flags_def_args_raw, delimiter='--')
  to_be_parsed_parser = argparse.ArgumentParser(prog=external_cmd_name, usage=PARSED_ARGS.usage, description=PARSED_ARGS.description, formatter_class=argparse.RawTextHelpFormatter, add_help=False)
  defaults = {}
  flag_ids_map = {}
  for fda in flags_def_args:
    if len(fda) == 0:
      continue
    FLAGS_DEF = flags_def_parser.parse_args(fda)
    if not FLAGS_DEF.short and not FLAGS_DEF.long:
      write_stderr('Either short or long name is required', end='\n')
      exit(ERROR_CODE.USAGE)
    flag_id = FLAGS_DEF.long if FLAGS_DEF.long else FLAGS_DEF.short
    flag_names = []
    if FLAGS_DEF.short:
      flag_names.append(f'-{FLAGS_DEF.short}')
    if FLAGS_DEF.long:
      flag_names.append(f'--{FLAGS_DEF.long}')
    if FLAGS_DEF.long:
      flag_ids_map[f'--{FLAGS_DEF.long}'] = flag_id
    elif FLAGS_DEF.short:
      flag_ids_map[f'-{FLAGS_DEF.short}'] = flag_id
    flag_help: str = FLAGS_DEF.help
    if flag_help:
      try:
        flag_help = ast.literal_eval('"%s"' % flag_help)
      except SyntaxError:
        flag_help = ast.literal_eval("'%s'" % flag_help)
    if FLAGS_DEF.type == 'bool':
      to_be_parsed_parser.add_argument(*flag_names, action='store_true', help=flag_help, default=False)
    else:
      to_be_parsed_parser.add_argument(*flag_names, type=validate_flag_values(FLAGS_DEF), metavar='', action='append', required=FLAGS_DEF.required, help=flag_help, default=None)
    # Storing defaults
    if FLAGS_DEF.default and flag_id:
      defaults[flag_id] = FLAGS_DEF.default
  help_flag_overriden = True
  try:
    to_be_parsed_parser.add_argument('-h', '--help', action='store_true', help="show this help message and exit")
    help_flag_overriden = False
  except argparse.ArgumentError:
    pass
  if not help_flag_overriden and len([x for x in to_be_parsed if x == '-h' or x == '--help']) > 0:
    write_stdout(' '.join(['--help', stringify_flag_value(to_be_parsed_parser.format_help())]), end=None)
  else:
    EXTERNAL_FLAGS, unparsed = to_be_parsed_parser.parse_known_args(to_be_parsed)
    unrecognized = []
    for u in unparsed:
      if u.startswith('-'):
        unrecognized.append(u)
    if unrecognized:
      write_stderr(f'{external_cmd_name}: error: unrecognized arguments: {unrecognized}', end='\n')
      exit(ERROR_CODE.USAGE)
    # Setting defaults if arg is not provided.
    for k in defaults:
      if EXTERNAL_FLAGS.__dict__[k] is None:
        EXTERNAL_FLAGS.__dict__[k] = defaults[k]
    parsed_args = []
    for k, v in flag_ids_map.items():
      val = EXTERNAL_FLAGS.__dict__[v]
      if isinstance(val, list):
        for x in val:
          parsed_args.append(k)
          parsed_args.append(stringify_flag_value(x))
      else:
        parsed_args.append(k)
        parsed_args.append(stringify_flag_value(val))
    parsed_args.append('--')
    parsed_args.extend([stringify_flag_value(x) for x in unparsed])
    write_stdout(' '.join(parsed_args))

def exec(external_args, flags_def_parser):
  if PARSED_ARGS.__subcommand__ == 'parse':
    parse_cmd(external_args, flags_def_parser)

def write_stdout(data, end=None):
  data = str(data)
  if end:
    data = data + end
  sys.stdout.write(data)

def write_stderr(data, end=None):
  data = str(data)
  if end:
    data = data + end
  sys.stderr.write(data)

def main():
  global PARSED_ARGS, PROG
  all_args = sys.argv[1:]
  internal_args, external_args = split_list_by_first_occurrence(all_args, '----', n=1)
  root_parser = argparse.ArgumentParser(description='A tool to parse and validate flags from command line arguments', formatter_class=argparse.RawTextHelpFormatter)
  PROG = root_parser.prog
  if len(all_args) == 0:
    write_stderr('No args provided.', end='\n')
    exit(ERROR_CODE.ERROR)
  sub_parsers = root_parser.add_subparsers(dest='__subcommand__')
  parse_parser, flags_def_parser = add_parse_subparser(sub_parsers)
  PARSED_ARGS = root_parser.parse_args(internal_args)
  exec(external_args, flags_def_parser)

if __name__ == '__main__':
  main()
